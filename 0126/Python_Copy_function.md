# 3. 복사가 잘 된 건가?
>  아래의 코드를 실행 하였을 때, 변수 a와 b에 담긴 list의 요소가 같은지 혹은 다른지 여부를 판단하고 그 이유를 작성하시오.

```python
a = [1,2,3,4,5]
b = a
a[2]=5

print(a)
print(b)
```





*sol)*

```python
a = [1,2,3,4,5]
b = a
a[2]=5

print(a)
print(b)
```

```
[1, 2, 5, 4, 5]
[1, 2, 5, 4, 5]
```



- a와 b 리스트의 요소는 같습니다

- list는 mutable 객체인데, 얕은복사를 적용했기 때문입니다.



## 얕은 복사

> 위와 같은 상황을 방지하려면, 슬라이싱 혹은 copy 메소드를 이용하는 방법이 있다.

```python
# 슬라이싱
a = [1,2,3,4,5]
b = a[:]
a[2]=5

print(a)
print(b)
```

```
[1, 2, 5, 4, 5]
[1, 2, 3, 4, 5]
```



```python
# copy 메소드
a = [1,2,3,4,5]
b = a.copy()
a[2]=5

print(a)
print(b)
```

```
[1, 2, 5, 4, 5]
[1, 2, 3, 4, 5]
```



- 하지만 이 또한 얕은 복사에 해당하며, 원소가 mutable한 객체일 때 또 문제가 발생한다.
- id를 확인해보면 id(a)와 id(b)는 다르지만, 그 내부의 객체 id(a[0])와 id(b[0])는 여전히 같은 메모리 주소를 나타내고 있기 때문이다.

```python
a = [[55,44,66,88],[12,45,78]]
b = a[:]
print(id(a))
print(id(b))
print('='*20)
print(id(a[0]))
print(id(b[0]))
```

```
2073245487040
2073246637760
====================
2073246169344
2073246169344
```



- 그러므로 다음과 같이 a[1]의 값을 변경하면 b[1]도 변경되어버린다.

```python
print(a)
print(b)
```

```
[[55, 44, 66, 88], [12, 45, 78]]
[[55, 44, 66, 88], [12, 45, 78]]
```



```python
a[1].append(33)
print(a)
print(b) # b[1]도 바뀌어버렸다.
```

```
[[55, 44, 66, 88], [12, 45, 78, 33]]
[[55, 44, 66, 88], [12, 45, 78, 33]]
```



> 이를 방지하기 위해 우리는 깊은 복사(deep copy)를 사용할 수가 있다.

```python
from copy import deepcopy
a = [[55,44,66,88],[12,45,78]]
b = deepcopy(a)
print(a)
print(b)
```

```
[[55, 44, 66, 88], [12, 45, 78]]
[[55, 44, 66, 88], [12, 45, 78]]
```



```python
a[1].append(33)
print(a)
print(b) # b[1]은 바뀌지 않는다.
```

```
[[55, 44, 66, 88], [12, 45, 78, 33]]
[[55, 44, 66, 88], [12, 45, 78]]
```



